<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SERPENT ‚Äî GameZone</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #020408;
    --grid: #0a1628;
    --accent: #00f5a0;
    --accent2: #00d9e8;
    --danger: #ff2d6b;
    --gold: #ffd700;
    --panel: rgba(0,245,160,0.06);
    --border: rgba(0,245,160,0.2);
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: #fff;
    font-family: 'Share Tech Mono', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }

  /* Animated background grid */
  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background-image:
      linear-gradient(rgba(0,245,160,0.03) 1px, transparent 1px),
      linear-gradient(90deg, rgba(0,245,160,0.03) 1px, transparent 1px);
    background-size: 40px 40px;
    animation: gridMove 20s linear infinite;
    pointer-events: none;
  }

  @keyframes gridMove {
    0% { transform: translateY(0); }
    100% { transform: translateY(40px); }
  }

  .glow-orb {
    position: fixed;
    width: 600px;
    height: 600px;
    border-radius: 50%;
    background: radial-gradient(circle, rgba(0,245,160,0.08) 0%, transparent 70%);
    top: -200px;
    right: -200px;
    pointer-events: none;
    animation: pulse 4s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { transform: scale(1); opacity: 0.6; }
    50% { transform: scale(1.1); opacity: 1; }
  }

  .wrapper {
    display: flex;
    gap: 24px;
    align-items: flex-start;
    position: relative;
    z-index: 1;
  }

  /* Left Panel */
  .side-panel {
    width: 180px;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .panel-box {
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 16px;
  }

  .panel-label {
    font-family: 'Orbitron', monospace;
    font-size: 9px;
    letter-spacing: 3px;
    color: var(--accent);
    margin-bottom: 8px;
    text-transform: uppercase;
  }

  .panel-value {
    font-family: 'Orbitron', monospace;
    font-size: 28px;
    font-weight: 900;
    color: #fff;
    line-height: 1;
  }

  .panel-value.highlight { color: var(--gold); }

  /* Main game area */
  .game-area {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
  }

  .game-header {
    text-align: center;
  }

  h1 {
    font-family: 'Orbitron', monospace;
    font-size: 32px;
    font-weight: 900;
    letter-spacing: 8px;
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: none;
    filter: drop-shadow(0 0 20px rgba(0,245,160,0.5));
  }

  .subtitle {
    font-size: 10px;
    letter-spacing: 4px;
    color: rgba(255,255,255,0.3);
    margin-top: 4px;
  }

  /* Canvas container */
  .canvas-wrap {
    position: relative;
    border: 1px solid var(--border);
    border-radius: 4px;
    overflow: hidden;
    box-shadow: 0 0 40px rgba(0,245,160,0.1), inset 0 0 40px rgba(0,0,0,0.5);
  }

  canvas {
    display: block;
    background: var(--grid);
  }

  /* Overlay screens */
  .overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(2,4,8,0.92);
    gap: 20px;
    transition: opacity 0.3s;
  }

  .overlay.hidden { opacity: 0; pointer-events: none; }

  .overlay-title {
    font-family: 'Orbitron', monospace;
    font-size: 42px;
    font-weight: 900;
    letter-spacing: 4px;
    color: var(--danger);
    filter: drop-shadow(0 0 20px rgba(255,45,107,0.7));
    animation: flicker 0.5s ease-in-out infinite alternate;
  }

  @keyframes flicker {
    from { opacity: 1; }
    to { opacity: 0.85; }
  }

  .overlay-score {
    font-family: 'Orbitron', monospace;
    font-size: 56px;
    font-weight: 900;
    color: var(--gold);
    filter: drop-shadow(0 0 20px rgba(255,215,0,0.5));
  }

  .overlay-text {
    font-size: 12px;
    letter-spacing: 3px;
    color: rgba(255,255,255,0.5);
    text-align: center;
  }

  .btn {
    font-family: 'Orbitron', monospace;
    font-size: 12px;
    font-weight: 700;
    letter-spacing: 4px;
    padding: 14px 40px;
    border: 1px solid var(--accent);
    background: transparent;
    color: var(--accent);
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.2s;
    position: relative;
    overflow: hidden;
  }

  .btn::before {
    content: '';
    position: absolute;
    inset: 0;
    background: var(--accent);
    transform: scaleX(0);
    transform-origin: left;
    transition: transform 0.2s;
    z-index: -1;
  }

  .btn:hover::before { transform: scaleX(1); }
  .btn:hover { color: var(--bg); }

  /* Status message */
  .status-msg {
    font-size: 11px;
    letter-spacing: 2px;
    color: rgba(255,255,255,0.4);
    height: 16px;
    transition: color 0.3s;
  }

  .status-msg.success { color: var(--accent); }
  .status-msg.error { color: var(--danger); }

  /* Controls */
  .controls {
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .key-hint {
    font-size: 10px;
    letter-spacing: 2px;
    color: rgba(255,255,255,0.25);
  }

  .key {
    display: inline-block;
    border: 1px solid rgba(255,255,255,0.2);
    padding: 2px 8px;
    border-radius: 3px;
    font-size: 10px;
  }

  /* Level display */
  .level-bar {
    width: 100%;
    height: 3px;
    background: rgba(255,255,255,0.05);
    border-radius: 2px;
    margin-top: 8px;
    overflow: hidden;
  }

  .level-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), var(--accent2));
    transition: width 0.3s;
    border-radius: 2px;
  }

  /* Score popup */
  .score-popup {
    position: absolute;
    font-family: 'Orbitron', monospace;
    font-size: 18px;
    font-weight: 900;
    color: var(--gold);
    pointer-events: none;
    animation: floatUp 0.8s ease-out forwards;
  }

  @keyframes floatUp {
    0% { opacity: 1; transform: translateY(0) scale(1); }
    100% { opacity: 0; transform: translateY(-60px) scale(1.3); }
  }
</style>
</head>
<body>

<div class="glow-orb"></div>

<div class="wrapper">
  <!-- Left panel -->
  <div class="side-panel">
    <div class="panel-box">
      <div class="panel-label">Score</div>
      <div class="panel-value" id="scoreDisplay">0</div>
    </div>
    <div class="panel-box">
      <div class="panel-label">Best</div>
      <div class="panel-value highlight" id="bestDisplay">0</div>
    </div>
    <div class="panel-box">
      <div class="panel-label">Level</div>
      <div class="panel-value" id="levelDisplay">1</div>
      <div class="level-bar"><div class="level-fill" id="levelBar" style="width:0%"></div></div>
    </div>
    <div class="panel-box">
      <div class="panel-label">Length</div>
      <div class="panel-value" id="lengthDisplay">3</div>
    </div>
  </div>

  <!-- Main game -->
  <div class="game-area">
    <div class="game-header">
      <h1>SERPENT</h1>
      <div class="subtitle">GAMEZONE ARCADE</div>
    </div>

    <div class="canvas-wrap">
      <canvas id="gameCanvas" width="500" height="500"></canvas>

      <!-- Start Overlay -->
      <div class="overlay" id="startOverlay">
        <div style="font-family:'Orbitron',monospace; font-size:14px; letter-spacing:6px; color:var(--accent);">READY PLAYER</div>
        <div class="overlay-score" style="font-size:72px;">üêç</div>
        <div class="overlay-text">USE ARROW KEYS OR WASD<br>EAT FOOD ¬∑ AVOID WALLS ¬∑ SURVIVE</div>
        <button class="btn" onclick="startGame()">START GAME</button>
      </div>

      <!-- Game Over Overlay -->
      <div class="overlay hidden" id="gameOverOverlay">
        <div class="overlay-title">GAME OVER</div>
        <div style="font-family:'Orbitron',monospace; font-size:12px; letter-spacing:3px; color:rgba(255,255,255,0.4);">FINAL SCORE</div>
        <div class="overlay-score" id="finalScore">0</div>
        <div class="status-msg" id="statusMsg">SUBMITTING SCORE...</div>
        <button class="btn" onclick="startGame()">PLAY AGAIN</button>
      </div>
    </div>

    <div class="controls">
      <span class="key-hint">MOVE</span>
      <span class="key">‚Üë‚Üì‚Üê‚Üí</span>
      <span class="key-hint">or</span>
      <span class="key">WASD</span>
      <span class="key-hint">&nbsp;|&nbsp; PAUSE</span>
      <span class="key">P</span>
    </div>
  </div>
</div>

<script>
// ============================================================
// CONFIGURATION ‚Äî Edit these for your GameZone backend
// ============================================================
const CONFIG = {
  // Your backend endpoint to post scores
  // It will receive: { score, level, length, gameName, playerName, timestamp }
  scoreEndpoint: 'https://your-backend.com/api/scores',

  // Game name identifier used in your gamezone
  gameName: 'serpent',

  // Get player info from URL params: ?userId=123&playerName=John
  // Your gamezone can pass these when embedding the game URL
  getUserFromURL: () => {
    const params = new URLSearchParams(window.location.search);
    return {
      userId: params.get('userId') || 'guest',
      playerName: params.get('playerName') || 'Player',
      sessionToken: params.get('token') || ''
    };
  }
};

// ============================================================
// GAME ENGINE
// ============================================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const GRID = 20;
const COLS = canvas.width / GRID;
const ROWS = canvas.height / GRID;

let snake, food, specialFood, dir, nextDir, score, best, level, gameLoop, running, paused;

const COLORS = {
  snakeHead: '#00f5a0',
  snakeBody: '#00c87a',
  snakeTail: '#006b45',
  food: '#ff2d6b',
  special: '#ffd700',
  grid: 'rgba(0,245,160,0.03)',
};

function init() {
  snake = [
    {x: 12, y: 10},
    {x: 11, y: 10},
    {x: 10, y: 10},
  ];
  dir = {x: 1, y: 0};
  nextDir = {x: 1, y: 0};
  score = 0;
  level = 1;
  specialFood = null;
  specialFoodTimer = 0;
  spawnFood();
  updateUI();
}

function spawnFood() {
  let pos;
  do {
    pos = {
      x: Math.floor(Math.random() * COLS),
      y: Math.floor(Math.random() * ROWS)
    };
  } while (snake.some(s => s.x === pos.x && s.y === pos.y));
  food = pos;
}

let specialFoodTimer = 0;

function spawnSpecialFood() {
  let pos;
  do {
    pos = {
      x: Math.floor(Math.random() * COLS),
      y: Math.floor(Math.random() * ROWS)
    };
  } while (snake.some(s => s.x === pos.x && s.y === pos.y) || (food.x === pos.x && food.y === pos.y));
  specialFood = pos;
  specialFoodTimer = 100; // disappears after 100 ticks
}

function getSpeed() {
  return Math.max(60, 200 - (level - 1) * 20);
}

function startGame() {
  document.getElementById('startOverlay').classList.add('hidden');
  document.getElementById('gameOverOverlay').classList.add('hidden');
  clearInterval(gameLoop);
  init();
  running = true;
  paused = false;
  best = parseInt(localStorage.getItem('serpent_best') || '0');
  document.getElementById('bestDisplay').textContent = best;
  scheduleLoop();
}

function scheduleLoop() {
  clearInterval(gameLoop);
  gameLoop = setInterval(tick, getSpeed());
}

function tick() {
  if (!running || paused) return;

  dir = { ...nextDir };

  const head = {
    x: snake[0].x + dir.x,
    y: snake[0].y + dir.y
  };

  // Wall collision
  if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) {
    return endGame();
  }

  // Self collision
  if (snake.some(s => s.x === head.x && s.y === head.y)) {
    return endGame();
  }

  snake.unshift(head);

  let ate = false;

  // Eat normal food
  if (head.x === food.x && head.y === food.y) {
    score += 10 * level;
    ate = true;
    showScorePopup(head, `+${10 * level}`);
    spawnFood();
    if (Math.random() < 0.25 && !specialFood) spawnSpecialFood();
  } else if (specialFood && head.x === specialFood.x && head.y === specialFood.y) {
    // Eat special food
    score += 50 * level;
    showScorePopup(head, `+${50 * level} ‚≠ê`);
    specialFood = null;
    ate = true;
  } else {
    snake.pop();
  }

  // Special food timer
  if (specialFood) {
    specialFoodTimer--;
    if (specialFoodTimer <= 0) specialFood = null;
  }

  // Level up every 5 normal foods
  const newLevel = Math.floor(snake.length / 5) + 1;
  if (newLevel > level) {
    level = newLevel;
    scheduleLoop(); // speed up
  }

  updateUI();
  draw();
}

function endGame() {
  running = false;
  clearInterval(gameLoop);

  if (score > best) {
    best = score;
    localStorage.setItem('serpent_best', best);
    document.getElementById('bestDisplay').textContent = best;
  }

  document.getElementById('finalScore').textContent = score;
  document.getElementById('gameOverOverlay').classList.remove('hidden');

  // Submit score to backend
  submitScore(score);
}

// ============================================================
// SCORE SUBMISSION
// ============================================================
async function submitScore(finalScore) {
  const statusEl = document.getElementById('statusMsg');
  const user = CONFIG.getUserFromURL();

  const payload = {
    userId: user.userId,
    playerName: user.playerName,
    gameName: CONFIG.gameName,
    score: finalScore,
    level: level,
    snakeLength: snake.length,
    timestamp: new Date().toISOString(),
    sessionToken: user.sessionToken
  };

  // Also post via window.parent for iframe integration
  try {
    window.parent.postMessage({
      type: 'GAME_SCORE',
      ...payload
    }, '*');
  } catch(e) {}

  // Post to backend API
  try {
    statusEl.textContent = 'SUBMITTING SCORE...';
    statusEl.className = 'status-msg';

    const res = await fetch(CONFIG.scoreEndpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...(user.sessionToken ? { 'Authorization': `Bearer ${user.sessionToken}` } : {})
      },
      body: JSON.stringify(payload)
    });

    if (res.ok) {
      statusEl.textContent = '‚úì SCORE SUBMITTED';
      statusEl.className = 'status-msg success';
    } else {
      statusEl.textContent = '‚ö† OFFLINE MODE';
      statusEl.className = 'status-msg error';
    }
  } catch (err) {
    statusEl.textContent = '‚ö† OFFLINE ‚Äî SCORE SAVED LOCALLY';
    statusEl.className = 'status-msg error';
    // Save locally as fallback
    saveScoreLocally(payload);
  }
}

function saveScoreLocally(payload) {
  const stored = JSON.parse(localStorage.getItem('serpent_offline_scores') || '[]');
  stored.push(payload);
  localStorage.setItem('serpent_offline_scores', JSON.stringify(stored.slice(-20)));
}

// ============================================================
// DRAWING
// ============================================================
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw subtle grid
  ctx.strokeStyle = COLORS.grid;
  ctx.lineWidth = 0.5;
  for (let x = 0; x <= COLS; x++) {
    ctx.beginPath(); ctx.moveTo(x * GRID, 0); ctx.lineTo(x * GRID, canvas.height); ctx.stroke();
  }
  for (let y = 0; y <= ROWS; y++) {
    ctx.beginPath(); ctx.moveTo(0, y * GRID); ctx.lineTo(canvas.width, y * GRID); ctx.stroke();
  }

  // Draw food
  drawFood(food.x, food.y, COLORS.food, '‚óè');

  // Draw special food (pulsing)
  if (specialFood) {
    const pulse = 0.6 + 0.4 * Math.sin(Date.now() / 150);
    ctx.globalAlpha = pulse;
    drawFood(specialFood.x, specialFood.y, COLORS.special, '‚òÖ');
    ctx.globalAlpha = 1;
  }

  // Draw snake
  snake.forEach((seg, i) => {
    const t = i / snake.length;
    const alpha = 1 - t * 0.5;
    ctx.globalAlpha = alpha;

    if (i === 0) {
      // Head with glow
      ctx.shadowBlur = 15;
      ctx.shadowColor = COLORS.snakeHead;
      ctx.fillStyle = COLORS.snakeHead;
    } else {
      ctx.shadowBlur = 0;
      ctx.fillStyle = i % 2 === 0 ? COLORS.snakeBody : COLORS.snakeTail;
    }

    const padding = i === 0 ? 1 : 2;
    roundRect(seg.x * GRID + padding, seg.y * GRID + padding, GRID - padding * 2, GRID - padding * 2, 3);
    ctx.fill();
  });

  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;

  // Eyes on head
  drawEyes();
}

function drawFood(x, y, color, symbol) {
  ctx.shadowBlur = 20;
  ctx.shadowColor = color;
  ctx.fillStyle = color;
  ctx.font = `${GRID - 4}px serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(symbol, x * GRID + GRID / 2, y * GRID + GRID / 2);
  ctx.shadowBlur = 0;
}

function drawEyes() {
  const head = snake[0];
  const cx = head.x * GRID + GRID / 2;
  const cy = head.y * GRID + GRID / 2;

  const offsets = dir.x !== 0
    ? [{dx: dir.x * 2, dy: -4}, {dx: dir.x * 2, dy: 4}]
    : [{dx: -4, dy: dir.y * 2}, {dx: 4, dy: dir.y * 2}];

  offsets.forEach(o => {
    ctx.fillStyle = '#020408';
    ctx.beginPath();
    ctx.arc(cx + o.dx, cy + o.dy, 2.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(cx + o.dx, cy + o.dy, 1.2, 0, Math.PI * 2);
    ctx.fill();
  });
}

function roundRect(x, y, w, h, r) {
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.lineTo(x + w - r, y);
  ctx.quadraticCurveTo(x + w, y, x + w, y + r);
  ctx.lineTo(x + w, y + h - r);
  ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
  ctx.lineTo(x + r, y + h);
  ctx.quadraticCurveTo(x, y + h, x, y + h - r);
  ctx.lineTo(x, y + r);
  ctx.quadraticCurveTo(x, y, x + r, y);
  ctx.closePath();
}

// ============================================================
// SCORE POPUP
// ============================================================
function showScorePopup(gridPos, text) {
  const wrap = document.querySelector('.canvas-wrap');
  const el = document.createElement('div');
  el.className = 'score-popup';
  el.textContent = text;
  el.style.left = (gridPos.x * GRID + GRID / 2) + 'px';
  el.style.top = (gridPos.y * GRID) + 'px';
  el.style.transform = 'translateX(-50%)';
  wrap.appendChild(el);
  setTimeout(() => el.remove(), 800);
}

// ============================================================
// UI UPDATE
// ============================================================
function updateUI() {
  document.getElementById('scoreDisplay').textContent = score;
  document.getElementById('levelDisplay').textContent = level;
  document.getElementById('lengthDisplay').textContent = snake.length;

  // Level progress bar (fills every 5 food eaten)
  const progress = ((snake.length - 3) % 5) / 5 * 100;
  document.getElementById('levelBar').style.width = progress + '%';
}

// ============================================================
// INPUT
// ============================================================
const DIRS = {
  ArrowUp: {x:0,y:-1}, ArrowDown: {x:0,y:1}, ArrowLeft: {x:-1,y:0}, ArrowRight: {x:1,y:0},
  w: {x:0,y:-1}, s: {x:0,y:1}, a: {x:-1,y:0}, d: {x:1,y:0},
  W: {x:0,y:-1}, S: {x:0,y:1}, A: {x:-1,y:0}, D: {x:1,y:0},
};

document.addEventListener('keydown', e => {
  if (e.key === 'p' || e.key === 'P') {
    paused = !paused;
    return;
  }

  const newDir = DIRS[e.key];
  if (!newDir) return;

  e.preventDefault();

  // Prevent reversing
  if (newDir.x === -dir.x && newDir.y === -dir.y) return;
  nextDir = newDir;
});

// Mobile swipe support
let touchStart = null;
canvas.addEventListener('touchstart', e => {
  touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
}, { passive: true });

canvas.addEventListener('touchend', e => {
  if (!touchStart) return;
  const dx = e.changedTouches[0].clientX - touchStart.x;
  const dy = e.changedTouches[0].clientY - touchStart.y;
  if (Math.abs(dx) > Math.abs(dy)) {
    nextDir = dx > 0 ? {x:1,y:0} : {x:-1,y:0};
  } else {
    nextDir = dy > 0 ? {x:0,y:1} : {x:0,y:-1};
  }
  if (nextDir.x === -dir.x && nextDir.y === -dir.y) nextDir = { ...dir };
  touchStart = null;
}, { passive: true });

// Initial draw
ctx.fillStyle = '#0a1628';
ctx.fillRect(0, 0, canvas.width, canvas.height);
</script>
</body>
</html>